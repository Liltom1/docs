import{_ as a,o,c,a5 as l}from"./chunks/framework.W6qmpZhh.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"next":{"text":"实现HTTP服务","link":"../Network/实现HTTP服务"},"prev":{"text":"OSI七层网络参考模型","link":"../Network/OSI七层网络参考模型"}},"headers":[],"relativePath":"Network/Tcp.md","filePath":"Network/Tcp.md","lastUpdated":1733476867000}'),d={name:"Network/Tcp.md"};function i(t,e,r,p,h,n){return o(),c("div",null,e[0]||(e[0]=[l('<h4 id="tcp" tabindex="-1"><code>Tcp</code> <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;`Tcp`&quot;">​</a></h4><p>相关名词</p><ul><li><p><code>seq</code>（sequence number），序列号随机生成的</p></li><li><p><code>ack</code>（acknowledgement number）确认号 <code>ack</code> = <code>seq</code>+ 1</p></li><li><p><code>ACK</code> （acknowledgement）确定序列号有效</p></li><li><p><code>SYN</code>（synchronous）发起新连接</p></li><li><p><code>FIN</code> （FINISH）完成</p></li></ul><h5 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h5><p>客户端与服务端</p><h6 id="_1-准备链接" tabindex="-1">1，准备链接 <a class="header-anchor" href="#_1-准备链接" aria-label="Permalink to &quot;1，准备链接&quot;">​</a></h6><p>TCP服务端创建传输控制模块<code>TCB</code>，进入LISTEN（监听）状态 ，TCP客户端也同样先创建传输控制模块<code>TCB</code> 。</p><h6 id="_2-tcp客户端发起第一次握手" tabindex="-1">2，TCP客户端发起第一次握手 <a class="header-anchor" href="#_2-tcp客户端发起第一次握手" aria-label="Permalink to &quot;2，TCP客户端发起第一次握手&quot;">​</a></h6><p>TCP客户端向服务器发出连接请求报文，报文参数如下</p><ul><li><p>报文中的首部位SYN = 1 ，预示着发起新链接</p></li><li><p>同时会附带一个seq=x(<em>一个随机的序列号 这里用x代替</em>)</p></li></ul><p>发送后<code>TCB</code>进入SYN-SENT（同步已发送状态），TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</p><h6 id="_3-tcp服务器接受请求-然后发起第二次握手" tabindex="-1">3，TCP服务器接受请求，然后发起第二次握手 <a class="header-anchor" href="#_3-tcp服务器接受请求-然后发起第二次握手" aria-label="Permalink to &quot;3，TCP服务器接受请求，然后发起第二次握手&quot;">​</a></h6><p>TCP服务器接受到请求后，同意链接，就会返回发出确认报文，报文中携带的参数有，</p><ul><li><code>ACK</code> = 1(你的请求序列号是有效的)</li><li><code>SYN</code> = 1 发起新链接</li><li><code>seq</code> = y （自己初始化一个随机的序列号）</li><li><code>ack</code> = x+1 (小写的<code>ack</code>为确认号，x为第一次客户端握手中的seq 随机序列号 )</li></ul><p>此时，TCP服务器进程进入了<code>SYN-RCVD</code>（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</p><h6 id="_4-tcp客户端接受到服务器返回-然后发起第三次握手" tabindex="-1">4，TCP客户端接受到服务器返回，然后发起第三次握手 <a class="header-anchor" href="#_4-tcp客户端接受到服务器返回-然后发起第三次握手" aria-label="Permalink to &quot;4，TCP客户端接受到服务器返回，然后发起第三次握手&quot;">​</a></h6><p>TCP客户进程收到确认后，还要向服务器给出确认，确认报文参数如下</p><ul><li><code>ACK</code> = 1(你的请求序列号是有效的)</li><li><code>seq</code> = x+1(x为第一次客户端握手中的seq 随机序列号 )</li><li><code> ack</code> = y+1 (y为第二次握手中服务器端的seq 随机序列号 )</li></ul><p>此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，<code>ACK</code>报文段可以携带数据，但是如果不携带数据则不消耗序号。</p><h6 id="_5-当服务器收到客户端的确认后也进入established状态-此后双方就可以开始通信了。" tabindex="-1">5，当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 <a class="header-anchor" href="#_5-当服务器收到客户端的确认后也进入established状态-此后双方就可以开始通信了。" aria-label="Permalink to &quot;5，当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。&quot;">​</a></h6><h5 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h5><h6 id="_1-客户端发送释放报文-并停止发送数据-第一次挥手" tabindex="-1">1.客户端发送释放报文，并停止发送数据 （第一次挥手） <a class="header-anchor" href="#_1-客户端发送释放报文-并停止发送数据-第一次挥手" aria-label="Permalink to &quot;1.客户端发送释放报文，并停止发送数据 （第一次挥手）&quot;">​</a></h6><p>释放数据报文首部</p><ul><li><p>FIN = 1（完成标识）</p></li><li><p>seq = u ( 等于前面已经传过来的数据的最后一个字节的序列号加1)</p></li></ul><p>然后客户端进入<code>FIN-WAIT1</code>（终止等待状态），TCP规定，FIN报文段即使不携带数据，也要消耗一个序号</p><h6 id="_2-服务端接受到客户端的释放报文-发出确认报文-第二次挥手" tabindex="-1">2.服务端接受到客户端的释放报文，发出确认报文 （第二次挥手） <a class="header-anchor" href="#_2-服务端接受到客户端的释放报文-发出确认报文-第二次挥手" aria-label="Permalink to &quot;2.服务端接受到客户端的释放报文，发出确认报文 （第二次挥手）&quot;">​</a></h6><p>服务端确认报文首部</p><ul><li><code>ack</code> = u +1 （确认号）</li><li><code>ACK</code> = 1 (确认序列号有效)</li><li><code>seq</code> = v （序列号）</li></ul><p>测试服务段就进入CLOSE-WAIT（关闭等待状态）TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p><p>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）</p><h6 id="_3-服务端发出释放报文-第三次挥手" tabindex="-1">3.服务端发出释放报文 （第三次挥手） <a class="header-anchor" href="#_3-服务端发出释放报文-第三次挥手" aria-label="Permalink to &quot;3.服务端发出释放报文 （第三次挥手）&quot;">​</a></h6><p>服务端的释放报文首部</p><ul><li><code>FIN</code> = 1 (释放报文标记)</li><li><code>ACK</code> = 1 （确认序列号有效）</li><li><code>seq</code> = w （序列号）</li><li><code>ack</code> = u+1 （确认号）</li></ul><p>此时，服务器就进入了<code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。</p><h6 id="_4-客户端收到服务端的释放报文-然后向服务端发出确认报文-第四次挥手" tabindex="-1">4.客户端收到服务端的释放报文，然后向服务端发出确认报文（第四次挥手） <a class="header-anchor" href="#_4-客户端收到服务端的释放报文-然后向服务端发出确认报文-第四次挥手" aria-label="Permalink to &quot;4.客户端收到服务端的释放报文，然后向服务端发出确认报文（第四次挥手）&quot;">​</a></h6><p>客户端的确认报文首部</p><ul><li><code>ACK</code> = 1</li><li><code>seq</code> = u + 1</li><li><code>ack</code> = w + 1</li></ul><p>此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2 ∗ * ∗<code>MSL</code>（最长报文段寿命，大概1-4分钟）的时间后，当客户端撤销相应的<code>TCB</code>后，才进入CLOSED状态。</p><p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销<code>TCB</code>后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>',39)]))}const T=a(d,[["render",i]]);export{u as __pageData,T as default};
