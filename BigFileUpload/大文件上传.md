## 大文件上传

本篇文章将实现一个大文件上传功能，并且将此功能封装成组件，并发布道npm。

大概实现了一下几点

- 大文件的切片上传

- 断点续传

- 提供了进度条的显示

- 低耦合高内聚

- 并发控制

- 打包后的npm包支持cjs,esm,引入

### 大文件的切片上传部分

在某些情况下，用户可能需要上传超大文件，此时如果一次性上传大文件，那将会**占用大量的网络带宽和服务器资源**，可能导致上传过程缓慢甚至失败。传输过程中如果出现网络中断需要**重新上传整个文件**所以需要进行断点续传。

#### 分片上传

- 将文件分割成多个小分片，每个分片可以**独立上传**，这样可以充分利用网络带宽，提高上传速度

- 上传过程中出现网络中断或服务器错误，**只需要重新上传失败的分片**，而不需要重新上传整个文件

- 每个分片可以独立上传，因此**支持断点续传功能**

#### 并发控制

- 通过设置合理的并发请求数，**避免过多并发请求导致的网络拥塞或服务器压力过大**
- 保持服务器的稳定性和响应速度，减少卡顿、降低失败概率

##### 实现思路

#### 1.切

获取文件并将文件进行分片，类似字符串，利用slice方法将文件分成一个个小切片存放在**`chunks`**数组中

```js
  const files = e.target.files;
  // console.log(e, 'e');
  const fs = files[0]; //读取文件内容
  // console.log(fs.name);
  fs.state = 'pending'; //设置文件状态为待上传

  uploadFiles.value = [...uploadFiles.value, fs];
  const total = Math.ceil(fs.size / props.options.chunkSize); //切割的总数 也就是我们要掉23次接口
  console.log(total, 'total');

  //0-5 5-10 10-15 15-20 20-25 将文件分装成5M的块 并放入chunks数组中 props.options.chunkSize是按大小多少进行切分
  chunks.push(...Array.from({ length: total }, (_, i) => fs.slice(i * props.options.chunkSize, (i + 1) * props.options.chunkSize)));

```

#### 2.MD5计算文件的hash值

为了让后端区分哪些分片是同一个大文件的, 这一步我们放到worker.js子进程去做，可能文件很大，计算需要很久，为了不能耽误主进程的渲染，不然页面会卡顿

主页面

```js
const worker = new Worker('../worker.js')
const handleChange = (e) => {
  // inputRef.value.click()
  const files = e.target.files;
  // console.log(e, 'e');
  const fs = files[0]; //读取文件内容
  // console.log(fs.name);
  fs.state = 'pending'; //设置文件状态为待上传

  uploadFiles.value = [...uploadFiles.value, fs];
  const total = Math.ceil(fs.size / props.options.chunkSize); //切割的总数 也就是我们要掉23次接口
  console.log(total, 'total');

  //0-5 5-10 10-15 15-20 20-25 将文件分装成5M的块 并放入chunks数组中 props.options.chunkSize是按大小多少进行切分
  chunks.push(...Array.from({ length: total }, (_, i) => fs.slice(i * props.options.chunkSize, (i + 1) * props.options.chunkSize)));

  console.log(chunks, 'chunks');
  //将切片数组传到web worker，多线程脚本运行上传到后端
  //向worker.js发送消息  worker.js会接收这个消息
  worker.postMessage({
    chunks,
    filename: fs.name,
  });

  console.log(worker, 'worker');
}
```

worker.js文件内容

```js
//web Woker浏览器的多线程脚本
//web worker 是运行在后台的js 不会阻塞页面
//可以进行计算 可以进行IO操作 但是不能进行DOM操作
//web worker 不能访问window对象 不能访问document对象
//self 代表当前的worker web worker 的全局作用域
self.importScripts('../spark-md5.min.js')
console.log(self,'self');

self.onmessage = function (e) {
    console.log(e.data, 'e.data')
    const { chunks, filename } = e.data;
    const spark = new self.SparkMD5.ArrayBuffer(); //计算MD5
    let currentChunk = 0;
    //需要把blob 转成 ArrayBuffer
    function loadNext() {
        const reader = new FileReader(); //各种格式转换base64 blob arraybuffer file
        reader.onload = function (e) {
            spark.append(e.target.result); //将数据 （每个切片）添加到spark中 MD5实例中
            currentChunk++;
            if (currentChunk < chunks.length) {
                loadNext();
            } else {
                //web Worker 可以发送消息给主线程
                self.postMessage({
                    filename,
                    hash: spark.end(), //递归完成后 整个文件会生成MD5  一整个文件的md5
                })
            }
        }
        reader.readAsArrayBuffer(chunks[currentChunk]); //读取文件 将文件转化为ArrayBuffer处理
    }
    loadNext()
}

```

#### 3.传

这里需要注意几个问题